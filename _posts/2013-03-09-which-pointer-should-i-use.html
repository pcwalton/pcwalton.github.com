<!DOCTYPE html>
<html>
  <head>
    <title>Which Pointer Should I Use? – pcwalton – pcwalton's blog</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>


<meta property="og:description" content="Deciding whether to use a managed @ pointer or an owned ~ pointer to allocate memory is one of the most frequent sources of confusion for newcomers to Rust. There are two main angles to consider when deciding whether to use an @ pointer or a ~ pointer in Rust: memory management and concurrency. I'll cover each in turn.
" />

<meta name="author" content="pcwalton" />


<meta property="og:title" content="Which Pointer Should I Use?" />
<meta property="twitter:title" content="Which Pointer Should I Use?" />



<meta property="og:image" content="http://pcwalton.github.com"/>
<meta property="twitter:image" content="http://pcwalton.github.com"/>



    <link rel="stylesheet" type="text/css" href="http://pcwalton.github.com/assets/style.css" />
    <link rel="alternate" type="application/rss+xml" title="pcwalton - pcwalton's blog" href="http://pcwalton.github.com/feed.xml" />
    <link rel="canonical" href="_posts/2013-03-09-which-pointer-should-i-use.html" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    {left: '$$$', right: '$$', display: true},
                    {left: '$$', right: '$$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

    <meta name="theme-color" content="#000000">
    <link rel="icon" type="image/png" sizes="32x32" href="http://pcwalton.github.com/images/favicon-32x32.png">
    

  </head>

  <body>
    <div id="bar"></div>
    <div class="wrapper-container">
      <div class="wrapper-masthead">
        <div class="container">
          <header class="masthead clearfix">
            

            <div class="site-info">
              <h1 class="site-name"><a href="http://pcwalton.github.com/">pcwalton</a></h1>
              <p class="site-description">pcwalton's blog</p> 
            </div>

            <nav>
              <a href="http://pcwalton.github.com/">Home</a>
            </nav>
          </header>
        </div>
      </div>

      <div class="wrapper-main">
        <div id="main" role="main" class="container">

<article class="post detailed">
  <h1>Which Pointer Should I Use?</h1>

  <div>
    <p class="author_title">Patrick Walton  ·  March  9, 2013</p>
    
    <div class="post-tags">
      
        
      
      
    </div>
  </div>
    
  <div class="entry">
    <p>Deciding whether to use a managed <code>@</code> pointer or an owned <code>~</code> pointer to allocate memory is one of the most frequent sources of confusion for newcomers to Rust. There are two main angles to consider when deciding whether to use an <code>@</code> pointer or a <code>~</code> pointer in Rust: <em>memory management</em> and <em>concurrency</em>. I'll cover each in turn.</p>
<p>Note that this tutorial only presents the basic system. There are many extensions to the system—borrowing, library smart pointers, cells, and so on—that allow the various limitations described here to be overcome. But this is the core system that needs to be understood first.</p>
<h1>Memory management</h1>
<p>One of the most important features of Rust from a systems programming perspective is that garbage collection is optional. What this means is that there are safe ways to allocate memory that do not require bookkeeping at runtime to determine when it is safe to free that memory.</p>
<p>What makes it possible for Rust programs to avoid runtime garbage collection is the notion of <em>ownership</em> of a particular allocation. Under this scheme, when the single owner of an allocation goes out of scope, the allocation is freed. Owned pointers in Rust are notated with <code>~</code>. Here's an example of their use:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">struct Point {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    x: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    y: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn f() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let x: ~Point = ~Point { x: 10, y: 20 };  // allocate a Point on the heap
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}  // &lt;-- x is freed here
</span></pre>
<p>Here, <code>x</code> is the single owner of the <code>Point</code> on the heap. Because there is only a single owner, Rust can throw away the memory pointed to by <code>x</code> at the end of the function.</p>
<p>The compiler enforces that there is only a single owner. Assigning the pointer to a new location <em>transfers ownership</em> (known as a <em>move</em> for short). Consider this program:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn g() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let a: ~Point = ~Point { x: 10, y: 20 }; // allocate a Point on the heap
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let b = a;                               // now b is the owner
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(b.x.to_str());                   // OK
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(a.x.to_str());                   // ERROR: use of moved value
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">} // &lt;-- b is freed here
</span></pre>
<p>When compiling this program, the compiler produces the error &quot;use of moved value&quot;. This is because assigning an owned pointer transfers ownership, making the old variable <em>dead</em>. Because the compiler knows precisely which variables are dead at all times, it can avoid having to determine at runtime whether to free the memory that a variable points to, and it can prevent you from accidentally accessing dead variables. However, this comes at a price: you are limited to using a single variable to refer to an <code>~</code> allocation.</p>
<p>By contrast, <code>@</code> pointers do not have this limitation. We think of memory that is allocated with <code>@</code> as <em>owned by the garbage collector</em>. You can make as many pointers to <code>@</code> memory as you would like. There is a cost in runtime performance, but this cost comes with a great deal of flexibility. For example, the code above will compile with an <code>@</code> pointer:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn h() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let a: @Point = @Point { x: 10, y: 20 }; // allocate a Point on the heap
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let b = a;                               // a and b share a reference
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(b.x.to_str());                   // OK
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(a.x.to_str());                   // also OK
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>So, in short: <em><code>@</code> pointers require garbage collection, but allow multiple pointers to the same location. <code>~</code> pointers avoid this GC overhead, but they don't allow multiple pointers to the same location.</em></p>
<h1>Concurrency</h1>
<p>Another equally important aspect to the distinction between <code>@</code> and <code>~</code> is that it ensures that concurrent Rust tasks don't race on shared memory. To illustrate this, here's an example of broken code that doesn't compile:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">struct Counter {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    count: int
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn f() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    // Allocate a mutable counter.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let counter: @mut Counter = @mut Counter { count: 0 };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	do spawn {               // spawn a new thread
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		// Increment the counter.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		counter.count += 1;  // ERROR: attempt to capture an `@` value
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(counter.count.to_str()); // print the value
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>This code contains a classic <em>race</em>—if this code compiled, then the value printed would be either 0 or 1, depending on whether the <code>counter.count += 1</code> line executed first or the <code>println</code> executed first. The key here is that two threads—the spawned thread and the main thread—are both simultaneously attempting to access the <code>counter</code> object. To prevent these errors, Rust prevents multiple threads from accessing the same memory at the same time.</p>
<p>Recall from the previous section that there can be any number of pointers to memory allocated with <code>@</code>. But there can be only one pointer to memory allocated with <code>~</code>. This suggests a way to forbid multiple threads from accessing the same data: <em>restrict the types of pointers that can be sent between threads to <code>~</code> pointers</em>. And this is exactly what Rust does.</p>
<p>For any piece of <code>~</code>-allocated memory, there is only one pointer to it, and that pointer is owned by exactly one thread. So there can be no races, since any other threads simply don't have access to that memory. Let's rewrite our example above using <code>~</code> to illustrate this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn g() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    // Allocate a mutable counter.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let mut counter: ~Counter = ~Counter { count: 0 };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    do spawn {               // spawn a new thread
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    counter.count += 1;  // increment the counter
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	println(counter.count.to_str()); // ERROR: use of moved value
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>What's going on here is that, by referring to <code>counter</code> inside the <code>spawn</code> block, the new thread <em>takes ownership</em> of the <code>counter</code> variable, and the <code>counter</code> variable becomes dead everywhere outside that block. Essentially, the main thread loses access to <code>counter</code> by <em>giving it away</em> to the thread it spawns. So the attempt to print the value on the screen from the main thread will fail. By contrast, this code will work:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn h() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    // Allocate a mutable counter.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let mut counter: ~Counter = ~Counter { count: 0 };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    do spawn {               // spawn a new thread
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        counter.count += 1;  // increment the counter
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        println(counter.count.to_str()); // OK: `counter` is owned by this thread
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Notice that the data race is gone: this code always prints <code>1</code>, because the printing happens in the thread that owns the <code>Counter</code> object.</p>
<p>The resulting rule is pretty simple. In short: <em><code>@</code> pointers may not be sent from thread to thread. <code>~</code> pointers may be sent, and are owned by exactly one thread at a time.</em> Therefore, if you need data to be sent, do not allocate it with <code>@</code>.</p>
<h1>Conclusion (TL;DR)</h1>
<p>So the distinction between <code>@</code> and <code>~</code> is often confusing to newcomers, but it's really quite simple. There are two main rules to remember:</p>
<ol>
<li>
<p><code>~</code> only supports one pointer to each allocation, so if you need multiple pointers to the same data, use <code>@</code>. But <code>@</code> requires garbage collection overhead, so if this is important to your application, use <code>~</code> wherever possible.</p>
</li>
<li>
<p>Don't use <code>@</code> pointers if you need to send data between multiple threads. Use <code>~</code> instead.</p>
</li>
</ol>
<p>Finally, I should note again that, if these rules are too restrictive for you (for example, if you need multiple pointers but can't tolerate garbage collection pauses), there are more advanced solutions: borrowing, safe smart pointers, and unsafe code. But this simple system works well for many programs and forms the foundation of Rust's approach to memory management.</p>

  </div>

  <div>
    <p><span class="share-box">Share:</span> <a href="http://twitter.com/share?text=Which Pointer Should I Use?&url=_posts/2013-03-09-which-pointer-should-i-use.html" target="_blank">Twitter</a>, <a href="https://www.facebook.com/sharer.php?u=_posts/2013-03-09-which-pointer-should-i-use.html" target="_blank">Facebook</a></p>
  </div>

  <!--<div class="date">
    Written on March  9, 2013
  </div>-->
</article>
        </div>
      </div>

      <div class="wrapper-footer">
        <div class="container">
          <footer class="footer">
            














          </footer>
        </div>
      </div>
    </div>

    

  </body>
</html>

