<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Typestate Is Dead, Long Live Typestate! – pcwalton – pcwalton's blog</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>


<meta property="og:description" content="One well-known fact about Rust is that the typestate system, which was one of the most unique aspects of the language early on, was dropped in Rust 0.4. The reason was that &quot;in practice, it found little use&quot; (courtesy of Wikipedia), which is fairly accurate. However, what's less well known is that, in the meantime, Rust gained the building blocks necessary for typestate via its uniqueness typing system. With the right patterns, most of the safety guarantees that typestate enabled can be achieved, although it's not as easy to use.
" />

<meta name="author" content="pcwalton" />


<meta property="og:title" content="Typestate Is Dead, Long Live Typestate!" />
<meta property="twitter:title" content="Typestate Is Dead, Long Live Typestate!" />



<meta property="og:image" content="http://pcwalton.github.io"/>
<meta property="twitter:image" content="http://pcwalton.github.io"/>



    <link rel="stylesheet" type="text/css" href="http://pcwalton.github.io/assets/style.css" />
    <link rel="alternate" type="application/rss+xml" title="pcwalton - pcwalton's blog" href="http://pcwalton.github.io/feed.xml" />
    <link rel="canonical" href="_posts/2012-12-26-typestate-is-dead.html" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    {left: '$$$', right: '$$', display: true},
                    {left: '$$', right: '$$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

    <meta name="theme-color" content="#000000">
    <link rel="icon" type="image/png" sizes="32x32" href="http://pcwalton.github.io/images/favicon-32x32.png">
    

  </head>

  <body>
    <div id="bar"></div>
    <div class="wrapper-container">
      <div class="wrapper-masthead">
        <div class="container">
          <header class="masthead clearfix">
            

            <div class="site-info">
              <h1 class="site-name"><a href="http://pcwalton.github.io/">pcwalton</a></h1>
              <p class="site-description">pcwalton's blog</p> 
            </div>

            <nav>
              <a href="http://pcwalton.github.io/">Home</a>
            </nav>
          </header>
        </div>
      </div>

      <div class="wrapper-main">
        <div id="main" role="main" class="container">

<article class="post detailed">
  <h1>Typestate Is Dead, Long Live Typestate!</h1>

  <div>
    <p class="author_title">Patrick Walton  ·  December 26, 2012</p>
    
    <div class="post-tags">
      
        
      
      
    </div>
  </div>
    
  <div class="entry">
    <p>One well-known fact about Rust is that the typestate system, which was one of the most unique aspects of the language early on, was dropped in Rust 0.4. The reason was that &quot;in practice, it found little use&quot; (courtesy of Wikipedia), which is fairly accurate. However, what's less well known is that, in the meantime, Rust gained the building blocks necessary for typestate via its uniqueness typing system. With the right patterns, most of the safety guarantees that typestate enabled can be achieved, although it's not as easy to use.</p>
<p>Let's start with the simple example of a file that can be open or closed. We want to ensure at compile time that no methods that require the file to be open (for example, reading) can be called on the file while it is closed. With typestate, we would define the functions as follows:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">use core::libc;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">struct File {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    descriptor: int
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">pred is_open(file: File) -&gt; bool {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    return file.descriptor &gt;= 0;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn open(path: &amp;str) -&gt; File : is_open {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let file = File { descriptor: libc::open(path) };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    check is_open(file);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    return file;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn close(file: &amp;mut File) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    libc::close(file.descriptor);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    file.descriptor = -1;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn read(file: &amp;File : is_open, buf: &amp;mut [u8], len: uint) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    libc::read(file.descriptor, ...)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>And this is how this module might be used:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn main() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let file: File : is_open = open(&quot;hello.txt&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    read(&amp;file, ...);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    close(file);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    read(&amp;file, ...);    // error: expected File : is_open but found File
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    check is_open(file); // will fail at runtime
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>The constructs here that differ from Rust of today are:</p>
<ul>
<li>
<p><em>Constraints</em> are special type kinds that can be attached to types with the <code>:</code> syntax; e.g. <code>File : is_open</code>.</p>
</li>
<li>
<p>The <code>pred</code> keyword declares a <em>predicate</em> function, which defines both a function and a constraint.</p>
</li>
<li>
<p>All values have unconstrained types when initially constructed. To add a constraint to a type, we use the <code>check</code> keyword. The <code>check</code> expression evaluates a predicate and fails at runtime if the predicate returns <code>false</code>; otherwise, it adds the appropriate constraint to the type of the predicate's argument.</p>
</li>
</ul>
<p>Now let's look at how we could achieve this in current Rust. We use the <em>branding pattern</em>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">struct File&lt;State&gt; {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    priv descriptor: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">// Make the type noncopyable.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">impl&lt;T&gt; File&lt;T&gt; : Drop {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn finalize(&amp;self) {}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">struct Open(@Open);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">struct Closed(@Closed);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn check_open&lt;T&gt;(file: File&lt;T&gt;) -&gt; File&lt;Open&gt; {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    assert file.descriptor &gt;= 0;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let new_file: File&lt;Open&gt; = File {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        descriptor: file.descriptor
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    return new_file;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn open(path: &amp;str) -&gt; File&lt;Open&gt; {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let file: File&lt;Closed&gt; = File { descriptor: libc::open(path) };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let file: File&lt;Open&gt; = check_open(file);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    return file;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn close&lt;T&gt;(file: File&lt;T&gt;) -&gt; File&lt;Closed&gt; {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let new_file: File&lt;Closed&gt; = File {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        descriptor: -1
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    libc::close(file.descriptor);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    return new_file;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn read(file: &amp;File&lt;Open&gt;, buf: &amp;mut [u8], len: uint) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    libc::read(file.descriptor, ...)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Using this code has a different feel to it:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn main() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let file: File&lt;Open&gt; = open(&quot;hello.txt&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    read(&amp;file, ...);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let file: File&lt;Closed&gt; = close(file);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    read(&amp;file, ...);  // error: expected File&lt;Open&gt; but found File&lt;Closed&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let file: File&lt;Open&gt; = check_open(file); // will fail at runtime
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>The differences between this code and the original code using typestate are:</p>
<ul>
<li>
<p>Rather than directly altering the constraints attached to a value's type, the functions that change typestate take a value of one type and return a different value of a different type. For example, <code>close()</code> takes a value of <code>File&lt;T&gt;</code> for any state <code>T</code> and returns a value of type <code>File&lt;Closed&gt;</code>.</p>
</li>
<li>
<p>Instead of the built-in notion of a predicate, this code uses a <em>phantom type</em>. A phantom type is a type for which no values can be constructed—in this example, there is no way to construct a value of type <code>Open</code> or <code>Closed</code>. Instead, these types are solely used as &quot;markers&quot;. In the code above, a value of type <code>File&lt;Open&gt;</code> represents an open file, and a value of type <code>File&lt;Closed&gt;</code> represents a closed file. We call these <em>branded types</em>, because <code>File</code> is <em>branded</em> with the <code>Open</code> or <code>Closed</code> status. Generics (e.g. <code>File&lt;T&gt;</code>) can be used when the state of a file is irrelevant; e.g. if a function can operate on both closed or open files.</p>
</li>
<li>
<p><code>File</code> instances are made noncopyable. This is important to prevent code like this from compiling:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let file: File&lt;Open&gt; = open(&quot;hello.txt&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">let _: File&lt;Closed&gt; = close(file); // ignore the return value
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">read(&amp;file, ...);  // error: use of moved value `file`
</span></pre>
</li>
</ul>
<p>The important idea is that to get a closed file, you must first surrender your open file. The uniqueness system in Rust allows the compiler to ensure this: when you change typestates, you must move your original value away, and the compiler will ensure that you can't access it again.</p>
<ul>
<li>
<p>The file descriptor field is made private to the containing module. This is important to disallow other modules from forging open or closed <code>File</code> instances. Otherwise, other code could simply convert an open file to a closed file the same way <code>check_open</code> does:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let open_file: File&lt;Open&gt; = open(&quot;hello.txt&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">let closed_file: File&lt;Closed&gt; = close(open_file);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">let fake_open_file: File&lt;Open&gt; = File { descriptor: closed_file };
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">// ^^^ error: use of private field &#39;descriptor&#39;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">read(&amp;fake_open_file, ...);
</span></pre>
</li>
</ul>
<p>Since the <code>File</code> structure contains a private field, no code other than the containing module can create one. In this way, we ensure that nobody can forge instances of <code>File</code> and violate our invariants.</p>
<p>Now, it's obvious that this isn't perfect in terms of usability. For one, it's a design pattern, and design patterns are the sincerest form of request for syntax. I'm not particularly concerned about this aspect, however, because syntactic sugar is readily achievable with macros.</p>
<p>The issue that I'm concerned with is deeper. One nice thing about typestate as previously implemented is that you don't have to surrender your value; you can effectively &quot;mutate&quot; its type &quot;in-place&quot;. This saves you from writing temporary variables all over the place and also saves some (cheap) copies at runtime. For example, you can write:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let file = open(&quot;hello.txt&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">read(&amp;file, ...);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">close(file);
</span></pre>
<p>Instead of:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let file = open(&quot;hello.txt&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">read(&amp;file, ...);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">let file = close(file);
</span></pre>
<p>In Rust, however, this causes complications, which we never fully resolved. (In fact, this is part of what led to typestate's removal.) Suppose that <code>close</code> mutated the type of its argument to change it from <code>&amp;File&lt;Open&gt;</code> to <code>&amp;File&lt;Closed&gt;</code>. Then consider the following code:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">trait Foo {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn speak(&amp;self);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">impl File&lt;Open&gt; : Foo {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn speak(&amp;self) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    io::println(&quot;woof&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">trait Bar {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn speak(&amp;self, x: int);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">impl File&lt;Closed&gt; : Bar {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn speak(&amp;self) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    io::println(&quot;meow&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">let file = open(&quot;hello.txt&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">for 5.times {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    file.speak();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    close(&amp;file);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>How do we compile this code? The first time around the <code>for 5.times { ... }</code> loop, <code>file.speak()</code> should resolve to <code>Foo::speak</code>; the second time around, <code>file.speak()</code> should resolve to <code>Bar::speak</code>. Needless to say, this makes compiling extremely difficult: we would have to consider the lexical scope of every single method invocation and compile it for <em>each</em> possible predicate!</p>
<p>Because of these and other complications, mutating the type doesn't seem possible in the general case. We would certainly need to introduce some set of restrictions—perhaps we would need to formalize the notion of a &quot;constraint&quot; in the type system (probably by introducing a new type kind) and then introduce some restrictions on implementation declarations to prevent instances from depending on constraints. Whatever system we come up would be pretty complex and would require a fair bit of thought to get right.</p>
<p>So I'd like to try to play with the current setup and see how far we get with it. In future versions of the language (post-1.0), it might be worthwhile to try to allow some sort of in-place &quot;mutation&quot; of types, similar to languages with true typestate. Overall, though, the combination of uniqueness and branding places today's Rust in an interesting position, supporting much of the power that came with typestate in a simple system.</p>

  </div>

  <div>
    <p><span class="share-box">Share:</span> <a href="http://twitter.com/share?text=Typestate Is Dead, Long Live Typestate!&url=_posts/2012-12-26-typestate-is-dead.html" target="_blank">Twitter</a>, <a href="https://www.facebook.com/sharer.php?u=_posts/2012-12-26-typestate-is-dead.html" target="_blank">Facebook</a></p>
  </div>

  <!--<div class="date">
    Written on December 26, 2012
  </div>-->
</article>
        </div>
      </div>

      <div class="wrapper-footer">
        <div class="container">
          <footer class="footer">
            














          </footer>
        </div>
      </div>
    </div>

    

  </body>
</html>

