<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Maximally Minimal Classes for Rust – pcwalton – pcwalton's blog</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>


<meta property="og:description" content="Now that classes have been implemented as per the original proposal, the other Rusters and I have been starting to get a feel for the way they work out in practice. The results are positive, but not optimal. Although they definitely succeeded in avoiding the rigidity of traditional object-oriented languages like Java, they still have two basic problems: (1) they feel somewhat out of place with the rest of the language; and (2) they're still too heavyweight. Nevertheless, the functionality that they enabled is important, and we shouldn't sacrifice it.
" />

<meta name="author" content="pcwalton" />


<meta property="og:title" content="Maximally Minimal Classes for Rust" />
<meta property="twitter:title" content="Maximally Minimal Classes for Rust" />



<meta property="og:image" content="http://pcwalton.github.io"/>
<meta property="twitter:image" content="http://pcwalton.github.io"/>



    <link rel="stylesheet" type="text/css" href="http://pcwalton.github.io/assets/style.css" />
    <link rel="alternate" type="application/rss+xml" title="pcwalton - pcwalton's blog" href="http://pcwalton.github.io/feed.xml" />
    <link rel="canonical" href="_posts/2012-06-03-maximally-minimal-classes-for-rust.html" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    {left: '$$$', right: '$$', display: true},
                    {left: '$$', right: '$$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

    <meta name="theme-color" content="#000000">
    <link rel="icon" type="image/png" sizes="32x32" href="http://pcwalton.github.io/images/favicon-32x32.png">
    

  </head>

  <body>
    <div id="bar"></div>
    <div class="wrapper-container">
      <div class="wrapper-masthead">
        <div class="container">
          <header class="masthead clearfix">
            

            <div class="site-info">
              <h1 class="site-name"><a href="http://pcwalton.github.io/">pcwalton</a></h1>
              <p class="site-description">pcwalton's blog</p> 
            </div>

            <nav>
              <a href="http://pcwalton.github.io/">Home</a>
            </nav>
          </header>
        </div>
      </div>

      <div class="wrapper-main">
        <div id="main" role="main" class="container">

<article class="post detailed">
  <h1>Maximally Minimal Classes for Rust</h1>

  <div>
    <p class="author_title">Patrick Walton  ·  June  3, 2012</p>
    
    <div class="post-tags">
      
        
      
      
    </div>
  </div>
    
  <div class="entry">
    <p>Now that classes have been implemented as per the original proposal, the other Rusters and I have been starting to get a feel for the way they work out in practice. The results are positive, but not optimal. Although they definitely succeeded in avoiding the rigidity of traditional object-oriented languages like Java, they still have two basic problems: (1) they feel somewhat out of place with the rest of the language; and (2) they're still too heavyweight. Nevertheless, the functionality that they enabled is important, and we shouldn't sacrifice it.</p>
<p>Language design tends to go in cycles: we grow the language to accommodate new functionality, then shrink the language as we discover ways in which the features can be orthogonally integrated into the rest of the system. Classes seem to me to be on the upward trajectory of complexity; now it's time to shrink them down. At the same time, we shouldn't sacrifice the functionality that they enable.</p>
<p>In Rust, classes provide five main pieces of functionality that don't otherwise exist: (1) nominal records; (2) constructors; (3) privacy on the field level; (4) attached methods; and (5) destructors. I'll go over these five features in turn and discuss how each one could be simplified.</p>
<h2>Nominal records</h2>
<p>Classes in Rust are nominal records. A class in this form:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let mut health: int;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let name: str;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Is basically the moral equivalent of:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">enum monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    monster({
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    mut health: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    name: str
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    })
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Clearly, the class form is much easier to read and much less confusing for users of the language; &quot;enum&quot; makes little sense as there's nothing enumerated here. Nevertheless, there's a bit of unnecessary noise in the form of the <code>let</code> keyword. We could simplify it to:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    mut health: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    name: str
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>It's less typing, and it matches record syntax exactly.</p>
<h2>Constructors</h2>
<p>Those who have used Rust classes in their current form know that the above example class <code>monster</code> is incomplete. I still have to define a constructor for <code>monster</code>, like so:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let mut health: int;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let name: str;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    new(health: int, name: str) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    self.health = health;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		self.name = name;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>This is probably the most burdensome part of classes as they currently stand--having to repeat each field name four times, and each type twice, is annoying. Many languages have solutions for this (CoffeeScript and Dart, for example), so we could consider adopting one of these languages' syntactic sugar for something like:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let mut health: int;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let name: str;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    new(self.health, self.name) {}  // sugar for the above
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Unfortunately, it doesn't stop there. Constructors have other problems. For one, there can only be one constructor per class--this is far more restrictive than Java, which permits constructor overloading. Worse, constructors can't indicate that they failed; they can only fail the task or set some internal &quot;this failed&quot; flag, both of which are clearly unsatisfactory. The right way to report a recoverable error to the caller in Rust is to use the <code>result</code> type, but constructors can't return <code>result&lt;self&gt;</code>; they can only return <code>self</code>.</p>
<p>I think the easiest way to address these problems is, following the idea that classes are just nominal records, is to abolish constructors entirely and adopt record literal syntax for initializing classes. So a class like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    mut health: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    name: str
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Would be initialized with:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let foe = monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    health: 100,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    name: &quot;Bigfoot&quot;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>If you want to declare one or more &quot;constructor&quot; functions, perhaps to signal success or failure, that's easy; they're just functions in the same crate:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn monster(health: int, name: str) -&gt; result&lt;monster&gt; {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    if name == &quot;King Kong&quot; || name == &quot;Godzilla&quot; {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ret err(&quot;Trademark violation&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    ret ok(monster { health: health, name: name });
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>But note that you only have to write a constructor if you're doing something special, like returning an error or initializing private fields. If your class is simple and merely holds public state, then your callers can just use the record literal syntax to create instances of the class.</p>
<h2>Privacy</h2>
<p>Classes in Rust allow private fields:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let priv mut health: 100;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let name: str;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    ...
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn hit() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    self.health -= 10;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>This is extremely useful functionality for modularity. But Rust already has a mechanism for privacy, via exports. For example, in order to write an enum whose contents are hidden from the outside world:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">enum color {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    priv red;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    priv green;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    priv blue;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>(Note that the syntax here is changing; for posterity, I'm using the new syntax, but note that the code here doesn't work at the time of this writing, as it's not yet implemented.)</p>
<p>Only this module can construct instances of this enum, or even inspect its contents, because while the enum itself can be named, none of its variants can. So we could apply the same principle to fields of classes:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">mod A {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    mod B {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		    priv mut health: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		    name: str
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		fn hit(monster: &amp;monster) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">			monster.health -= 10;    // OK
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	fn heal(monster: &amp;monster) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        monster.health += 10;        // error: field &quot;health&quot; is private
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Here, a field marked with <code>priv</code> can only be named (and therefore accessed) by the enclosing module or containing modules. It works like every other instance of <code>priv</code> in the language: it restricts the use of a name to the enclosing module and its submodules.</p>
<p>It would be an error for modules that aren't the module defining the class or an enclosing module to attempt to construct an instance of a class with a private field with the record literal syntax. This means that, if you use private fields, you need a constructor if you want your class instances to be constructible by the outside world.</p>
<h2>Methods</h2>
<p>Naturally, Rust classes support attached methods; this is much of the reason for their existence. But Rust already has a mechanism for creating methods--namely, typeclasses. We could write the above <code>monster</code> declaration this way:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">mod A {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    priv mut health: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    name: str
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    impl monster for &amp;monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    fn hit() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		    self.health -= 10;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>The trick here is that the typeclass implementation is named <code>monster</code>, so a declaration like <code>import A::monster</code> will import both the class and the implementation. This entire scenario works because, with privacy restricted to the module, there is no need to place methods inside the class to achieve privacy.</p>
<p>Sometimes, it's useful to have the hidden <code>self</code> parameter actually be a GC'd pointer to an instance of the class. In the original class proposal, this is accomplished with a separate type of class named <code>@class</code>. However, with this revised proposal, the <code>@class</code> functionality falls out naturally, without any extra features:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">class monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    priv mut health: int,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    name: str,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    friends: dvec&lt;@monster&gt;  // a dynamic vector
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">impl monster for @monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn befriend(new_friend: @monster) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    new_friend.friends.push(self);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>It'd be best if we could eliminate the repetition of the <code>monster</code> name in the <code>impl</code> declaration, so I propose inferring it:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">impl for @monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn befriend(new_friend: @monster) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    new_friend.friends.push(self);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>The name of the implementation would automatically be inferred to be the name of the class if, given a class C, the type is one of <code>C</code>, <code>@C</code>, <code>~C</code>, or <code>&amp;C</code>.</p>
<p>Note that, since traits can be applied to implementations, we can apply traits to classes in this way.</p>
<p>It would be ideal to eliminate the <code>impl</code> declaration entirely. However, this relies on typeclass coherence, which I'd like to keep separate to avoid coupling proposals. Nevertheless, it's worth mentioning; so, in a forthcoming post, I'll show how typeclass coherence can make method declaration syntax even simpler.</p>
<h2>Destructors</h2>
<p>Classes are intended to be the only mechanism for destructors in Rust. Unfortunately, there's no obvious way to eliminate destructors from classes in a minimal way. There are a number of options:</p>
<ol>
<li>
<p>Keep destructors in classes, and remove resources.</p>
</li>
<li>
<p>Keep resources around, and remove destructors from classes.</p>
</li>
<li>
<p>Make the destructor interface (<code>drop</code>) into a special kind of &quot;intrinsic interface&quot; which enforces <em>instance coherence</em>. Then remove both resources and destructors from classes. (Recall that instance coherence means that each class can only have one implementation of an interface, which is clearly, to my mind, a necessity if destructors are to become an interface.)</p>
</li>
<li>
<p>Make <em>all</em> interfaces enforce instance coherence, make <code>drop</code> into an interface, and remove both resources and destructors from the language.</p>
</li>
</ol>
<p>I prefer option (4), but, as mentioned before, that's a separate issue.</p>
<p>Finally, with nearly all of the special functionality of classes removed, it's worth asking why records continue to exist. Indeed, I've been thinking for a while that structural records should be removed from the language, but the reasons for this tie into a deeper discussion on structural and nominal types and deserve their own blog post.</p>

  </div>

  <div>
    <p><span class="share-box">Share:</span> <a href="http://twitter.com/share?text=Maximally Minimal Classes for Rust&url=_posts/2012-06-03-maximally-minimal-classes-for-rust.html" target="_blank">Twitter</a>, <a href="https://www.facebook.com/sharer.php?u=_posts/2012-06-03-maximally-minimal-classes-for-rust.html" target="_blank">Facebook</a></p>
  </div>

  <!--<div class="date">
    Written on June  3, 2012
  </div>-->
</article>
        </div>
      </div>

      <div class="wrapper-footer">
        <div class="container">
          <footer class="footer">
            














          </footer>
        </div>
      </div>
    </div>

    

  </body>
</html>

