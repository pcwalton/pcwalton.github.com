<!DOCTYPE html>
<html>
  <head>
    <title>Revamped Parallel Layout in Servo – pcwalton – pcwalton's blog</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>


<meta property="og:description" content="Over the past week I've submitted a series of pull requests that significantly revamp the way parallel layout works in Servo. Originally I did this work to improve performance, but it's also turned out to be necessary to implement more advanced CSS 2.1 features. As it's a fairly novel algorithm (as far as I'm aware) I'd like to take some time to explain it. I'll start with where we are in Servo head and explain how it evolved into what's in my branch. This post assumes a little knowledge about how browser engines work, but little else.
" />

<meta name="author" content="pcwalton" />


<meta property="og:title" content="Revamped Parallel Layout in Servo" />
<meta property="twitter:title" content="Revamped Parallel Layout in Servo" />



<meta property="og:image" content="http://pcwalton.github.io"/>
<meta property="twitter:image" content="http://pcwalton.github.io"/>



    <link rel="stylesheet" type="text/css" href="http://pcwalton.github.io/assets/style.css" />
    <link rel="alternate" type="application/rss+xml" title="pcwalton - pcwalton's blog" href="http://pcwalton.github.io/feed.xml" />
    <link rel="canonical" href="_posts/2014-02-25-revamped-parallel-layout-in-servo.html" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    {left: '$$$', right: '$$', display: true},
                    {left: '$$', right: '$$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

    <meta name="theme-color" content="#000000">
    <link rel="icon" type="image/png" sizes="32x32" href="http://pcwalton.github.io/images/favicon-32x32.png">
    

  </head>

  <body>
    <div id="bar"></div>
    <div class="wrapper-container">
      <div class="wrapper-masthead">
        <div class="container">
          <header class="masthead clearfix">
            

            <div class="site-info">
              <h1 class="site-name"><a href="http://pcwalton.github.io/">pcwalton</a></h1>
              <p class="site-description">pcwalton's blog</p> 
            </div>

            <nav>
              <a href="http://pcwalton.github.io/">Home</a>
            </nav>
          </header>
        </div>
      </div>

      <div class="wrapper-main">
        <div id="main" role="main" class="container">

<article class="post detailed">
  <h1>Revamped Parallel Layout in Servo</h1>

  <div>
    <p class="author_title">Patrick Walton  ·  February 25, 2014</p>
    
    <div class="post-tags">
      
        
      
      
    </div>
  </div>
    
  <div class="entry">
    <p>Over the past week I've submitted a <a href="https://github.com/mozilla/servo/pull/1700">series of</a> <a href="https://github.com/mozilla/servo/pull/1734">pull requests</a> that significantly revamp the way parallel layout works in Servo. Originally I did this work to improve performance, but it's also turned out to be necessary to implement more advanced CSS 2.1 features. As it's a fairly novel algorithm (as far as I'm aware) I'd like to take some time to explain it. I'll start with where we are in Servo head and explain how it evolved into what's in my branch. This post assumes a little knowledge about how browser engines work, but little else.</p>
<h2>Overview</h2>
<p>Servo's layout operates on a <em>flow tree</em>, which is similar to the <em>render tree</em> in WebKit or Blink and the <em>frame tree</em> in Gecko. We call it a flow tree rather than a render tree because it consists of two separate data types: <em>flows</em>, which are organized in a tree, and <em>boxes</em>, which belong to flows and are organized in a flat list. Roughly speaking, a <em>flow</em> is an object that can be laid out in parallel with other flows, while a <em>box</em> is a box that must be laid out sequentially with other boxes in the same flow. If you're familiar with WebKit, you can think of a box as a <code>RenderObject</code>, and if you're familiar with Gecko, you can think of a box as a <code>nsFrame</code>. We want to lay out boxes in parallel as much as possible in Servo, so we group boxes into <em>flows</em> that can be laid out in parallel with one another.</p>
<p>Here's a simple example. Suppose we have the following document:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">&lt;html&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;body&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;p&gt;Four score and seven years ago our &lt;b&gt;fathers&lt;/b&gt; brought forth on this
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	continent, a new nation, conceived in Liberty, and dedicated to the
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	proposition that all men are created equal.&lt;/p&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;p&gt;Now we are engaged in a great civil war, testing whether that nation,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	or any nation so conceived and so dedicated, can long endure. We are met
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	on a great battle-field of that war. We have come to &lt;i&gt;dedicate&lt;/i&gt; a
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	portion of that field, as a final resting place for those who here gave
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	their lives that that nation might live. It is altogether fitting and
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	proper that we should do this.&lt;/p&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/body&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/html&gt;
</span></pre>
<p>This would result in the following flow tree:</p>
<p><img src="http://i.imgur.com/uNZSiET.png" alt="(Flow tree)" /></p>
<p>Notice that there are three inline boxes under each <code>InlineFlow</code>. We have multiple boxes for each because each contiguous sequence of text in the same style—known as a <em>text run</em>—needs a box. During layout, the structure of the flow tree remains immutable, but the boxes get cut up into separate lines, so there will probably be many more boxes after layout (depending on the width of the window).</p>
<p>One neat thing about this two-level approach is that boxes end up flattened into a flat list instead of a linked data structure, improving cache locality and memory usage and making style recalculation faster because less needs to be allocated. Another benefit (and in fact the original impetus for this data structure) is that the line breaking code need not traverse trees in order to do its work—it only needs to traverse a single array, making the code simpler and improving cache locality.</p>
<p>Now that we know how the flow tree looks, let's look at how Servo currently performs layout to figure out where boxes should go.</p>
<h2>The current algorithm</h2>
<p>The current algorithm for parallel layout in Servo (i.e. what's in the master branch before my changes) consists of three separate passes over the flow tree.</p>
<ol>
<li>
<p><em>Intrinsic width calculation</em> or <code>bubble_widths</code> (bottom-up). This computes the <em>minimum width</em> and <em>preferred width</em> for each flow. There are no sequential hazards here and this can always be computed in parallel. Note that this is information is not always needed during layout, and eventually we will probably want to implement optimizations to avoid computation of this information for subtrees in which it is not needed.</p>
</li>
<li>
<p><em>Actual width calculation</em> or <code>assign_widths</code> (top-down). This computes the width of each flow, along with horizontal margins and padding values.</p>
</li>
<li>
<p><em>Height calculation</em> or <code>assign_heights</code> (bottom-up). This computes the height of each flow. Along the way, line breaking is performed, and floats are laid out. We also compute vertical margins and padding, including margin collapse.</p>
</li>
</ol>
<p>Within each flow, boxes are laid out sequentially—this is necessary because, in normal text, where to place the next line break depends on the lines before it. (However, we may be able to lay boxes out in parallel for <code>white-space: nowrap</code> or <code>white-space: pre</code>.)</p>
<p>For simple documents that consist of blocks and inline flows, Servo achieves excellent parallel wins, in line with <a href="http://www.eecs.berkeley.edu/~lmeyerov/projects/pbrowser/pubfiles/playout.pdf">Leo Meyerovich's &quot;Fast and Parallel Webpage Layout&quot;</a>, which implemented this simple model.</p>
<h2>The problem with floats</h2>
<p>Unfortunately, in the real world there is one significant complication: floats. Here's an example of a document involving floats that illustrates the problem:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">&lt;div style=&quot;float: right&quot;&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	I shot the sheriff.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	But I swear it was in self-defense.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	I shot the sheriff.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	And they say it is a capital offense.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	I shot the sheriff
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	But I didn&#39;t shoot no deputy.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	All around in my home town,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	They&#39;re tryin&#39; to track me down;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	They say they want to bring me in guilty
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	For the killing of a deputy,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	For the life of a deputy.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span></pre>
<p>Rendered with a little extra formatting added, it looks like this:</p>
<div style='margin-left: auto; margin-right: auto; width: 300px; font: 14px "Times New Roman";'>
	<div style="float: right; width: 150px; white-space: pre-wrap; background-color: #0a0; color: white;">I shot the sheriff.
But I swear it was in self-defense.
I shot the sheriff.
And they say it is a capital offense.</div>
   <div style="white-space: pre-wrap">I shot the sheriff
But I didn't shoot no deputy.</div>
	<div style="white-space: pre-wrap; margin-top: 12px;">All around in my home town,
They're tryin' to track me down;
They say they want to bring me in guilty
For the killing of a deputy,
For the life of a deputy.</div>
</div>
<p>The flow tree for this document might look like this:</p>
<p><img src="http://i.imgur.com/s18ckTR.png" alt="(Flow tree)" /></p>
<p>Notice how the float in green (&quot;I shot the sheriff…&quot;) affects where the line breaks go in the two blocks to its left and below it (&quot;I shot the sheriff…&quot; and &quot;All around…&quot;). Line breaking is performed during the <em>height assignment</em> phase in Servo, because where the line breaks go determines the height of each flow.</p>
<p>This has important implications for the parallel algorithm described above. We don't know how tall the float is until we've laid it out, and its height determines where to place the line breaks in the blocks next to it, so we have to lay out the float before laying out the blocks next to it. This means that we have to lay out the float before laying out any blocks that it's adjacent to. But, more subtly, floats prevent us from laying out all the blocks that they impact in parallel as well. The reason is that we don't know how many floats &quot;stick out&quot; of a block until we know its height, and in order to perform line breaking for a block we have to know how many floats &quot;stuck out&quot; of all the blocks before it. Consider the difference between the preceding document and this one:</p>
<div style='margin-left: auto; margin-right: auto; width: 300px; font: 14px "Times New Roman";'>
	<div style="float: right; width: 150px; white-space: pre-wrap; background-color: #0a0; color: white;">I shot the sheriff.
But I swear it was in self-defense.
I shot the sheriff.
And they say it is a capital offense.</div>
   <div style="white-space: pre-wrap">I shot the sheriff
But I didn't shoot no deputy.
I shot the sheriff
But I didn't shoot no deputy.</div>
	<div style="white-space: pre-wrap; margin-top: 12px;">All around in my home town,
They're tryin' to track me down;
They say they want to bring me in guilty
For the killing of a deputy,
For the life of a deputy.</div>
</div>
<p>The only difference between the first document and the this one is that the first unfloated block (&quot;I shot the sheriff…&quot;) is taller. But this impacts the height of the second block (&quot;All around…&quot;), by affecting where the lines get broken. So the key thing to note here is that, in general, <em>floats force us to sequentialize the processing of the blocks next to them</em>.</p>
<p>The way this was implemented in Servo before my pull requests is that any floats in the document caused all unfloated blocks to be laid out sequentially. (The floats themselves could still be laid out in parallel, but all other blocks in the page were laid out in order.) Unsurprisingly, this caused our parallel gains to evaporate on most real-world Web pages. The vast majority of modern Web pages do use floats in some capacity, as they're one of the most popular ways to create typical layouts. So losing our parallel gains is quite unfortunate.</p>
<p>Can we do better? It turns out we can.</p>
<h2>Clearing floats</h2>
<p>As most designers know, the <code>float</code> property comes with a very useful companion property: <code>clear</code>. The <code>clear</code> property causes blocks to be shifted down in order to avoid impacting floats in one or both directions. For example, the document above with <code>clear: right</code> added to the second block looks like this:</p>
<div style='margin-left: auto; margin-right: auto; width: 300px; font: 14px "Times New Roman";'>
	<div style="float: right; width: 150px; white-space: pre-wrap; background-color: #0a0; color: white;">I shot the sheriff.
But I swear it was in self-defense.
I shot the sheriff.
And they say it is a capital offense.</div>
   <div style="white-space: pre-wrap">I shot the sheriff
But I didn't shoot no deputy.</div>
	<div style="clear: right; white-space: pre-wrap; margin-top: 12px;">All around in my home town,
They're tryin' to track me down;
They say they want to bring me in guilty
For the killing of a deputy,
For the life of a deputy.</div>
</div>
<p>This property is widely used on the Web to control where floats can appear, and we can take advantage of this to gain back parallelism. If we know that no floats can impact a block due to the use of the <code>clear</code> property, then we can lay it out in parallel with the blocks before it. In the document above, the second block (&quot;All around…&quot;) can be laid out at the same time as the float and the first block.</p>
<p>My second pull request implements this optimization in this way: During flow construction, which is a bottom-up traversal, we keep track of a flag, <code>has_floated_descendants</code>, and set it on each flow if it or any of its descendants are <code>FloatFlow</code> instances. (Actually, there are two such flags—<code>has_left_floated_descendants</code> and <code>has_right_floated_descendants</code>—but for the purposes of this explanation I'll just treat it as one flag.) During width computation, we iterate over our children and set two flags: <code>impacted_by_floats</code>. (Again, there are actually two such flags—<code>impacted_by_left_floats</code> and <code>impacted_by_right_floats</code>.) <code>impacted_by_floats</code> is true for a flow if and only if any of the following is true:</p>
<ol>
<li>
<p>The parent flow is impacted by floats.</p>
</li>
<li>
<p>The flow has floated descendants.</p>
</li>
<li>
<p>Any previous sibling flow is impacted by floats, <em>unless</em> the appropriate <code>clear</code> property has been set between this flow and that sibling.</p>
</li>
</ol>
<p>Only subtrees that have <code>impacted_by_floats</code> set to true are laid out sequentially, in order. The remaining subtrees can be laid out in parallel.</p>
<p>With this optimization implemented, documents above can be laid out in parallel as much as possible. It helps many real-world Web pages, as <code>clear</code> is a very commonly-used property.</p>
<p>At this point, two questions arise: &quot;Can we do even more?&quot; and &quot;Is this algorithm enough to properly handle CSS?&quot; As you might expect, the answer to the first is &quot;yes&quot;, and the answer to the second is &quot;no&quot;. To understand why, we need dive into the world of <em>block formatting contexts</em>.</p>
<h2>Block formatting contexts</h2>
<p>The behavior of <code>overflow: hidden</code> is subtle. Consider this document, which is identical to the document we've been using but with <code>overflow: hidden</code> specified on the blocks adjacent to the float:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">&lt;div style=&quot;float: right&quot;&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	I shot the sheriff.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	But I swear it was in self-defense.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	I shot the sheriff.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	And they say it is a capital offense.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;div style=&quot;overflow: hidden&quot;&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	I shot the sheriff
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	But I didn&#39;t shoot no deputy.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;div style=&quot;overflow: hidden&quot;&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	All around in my home town,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	They&#39;re tryin&#39; to track me down;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	They say they want to bring me in guilty
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	For the killing of a deputy,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	For the life of a deputy.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span></pre>
<p>Rendered, it looks like this:</p>
<div style='margin-left: auto; margin-right: auto; width: 300px; font: 14px "Times New Roman";'>
	<div style="float: right; width: 150px; white-space: pre-wrap; background-color: #0a0; color: white;">I shot the sheriff.
But I swear it was in self-defense.
I shot the sheriff.
And they say it is a capital offense.</div>
   <div style="overflow: hidden; white-space: pre-wrap">I shot the sheriff
But I didn't shoot no deputy.</div>
	<div style="overflow: hidden; white-space: pre-wrap; margin-top: 12px;">All around in my home town,
They're tryin' to track me down;
They say they want to bring me in guilty
For the killing of a deputy,
For the life of a deputy.</div></div>
</div>
<p>Notice that, with <code>overflow: hidden</code> specified, the float makes the entire width of the block next to it smaller: all the lines have been wrapped, not just those that impact the float. </p>
<p>What's going on here is that <code>overflow: hidden</code> establishes what's known as a [block formatting context] <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context">4</a> in CSS jargon. In Servo, block formatting contexts make our layout algorithm significantly more complex, because they require <em>width assignment and height assignment to be intertwined</em>, and for <em>height assignment to be interruptible</em>. To see why this is, recall that the flow tree for this document looks like this:</p>
<p><img src="http://i.imgur.com/s18ckTR.png" alt="(Flow tree)" /></p>
<p>Remember that Servo's layout algorithm performs width calculation top-down, then height calculation bottom-up—this works under the assumption that widths never depend on heights. But with block formatting contexts adjacent to floats, this is no longer true: <em>the width of a block formatting context depends on the height of floats next to it</em>. This is because we don't know whether a float, such as the green float above, is tall enough to impact a block formatting context, like those that the &quot;I shot the sheriff…&quot; and &quot;All around…&quot; above establish, until we lay out all blocks prior to the context and the float itself. And without knowing that, we cannot assign the width of the block formatting contexts.</p>
<p>To handle this case, my patches change Servo's layout in several ways:</p>
<ol>
<li>
<p>When we see a block formatting context during width calculation, we check the value of the <code>impacted_by_floats</code> flag. If it is on, then we don't calculate widths for that flow or any of its descendants. Instead, we set a flag called <code>width_assignment_delayed</code>.</p>
</li>
<li>
<p>When we encounter a block formatting context child of a flow while calculating heights, if that block formatting context has the flag <code>width_assignment_delayed</code> set, we <em>suspend</em> the calculation of heights for that node, calculate the width of the block formatting context, and begin calculating widths and heights for that node and all of its descendants (in parallel, if possible).</p>
</li>
<li>
<p>After calculating the height of a block formatting context, we <em>resume</em> calculation of heights for its parent.</p>
</li>
</ol>
<p>Let's look at the precise series of steps that we'll follow for the document above:</p>
<ol>
<li>
<p>Calculate the width of the root flow.</p>
</li>
<li>
<p>Calculate the width of the float flow.</p>
</li>
<li>
<p>Don't calculate the widths of the two block flows; instead, set the <code>width_assignment_delayed</code> flag.</p>
</li>
<li>
<p>Calculate the width of the float flow's inline flow child. The main width assignment phase is now complete.</p>
</li>
<li>
<p>Begin height calculation. First, calculate the height of the float flow and its inline child.</p>
</li>
<li>
<p>Start calculating the height of the root flow by placing the float.</p>
</li>
<li>
<p>We see that we've hit a block formatting context that has its width assignment delayed, so we clear that flag, determine its width, and start width calculation for its descendants.</p>
</li>
<li>
<p>Calculate width for the block flow's inline child. Now width calculation is done for that subtree.</p>
</li>
<li>
<p>Calculate the height of the block flow's inline child, and the block flow itself. Now height calculation is done for this subtree.</p>
</li>
<li>
<p>Resume calculating the height of the root flow. We see that the next block formatting context has its width assignment delayed, so we assign its width and repeat steps 8 and 9.</p>
</li>
<li>
<p>We've now calculated the height of the root flow, so we're done.</p>
</li>
</ol>
<p>Now this particular page didn't result in any parallel speedups. However, block formatting contexts can result in additional parallelism in some cases. For example, consider this document:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">&lt;div id=sidebar style=&quot;float: left&quot;&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;div&gt;Coupons&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;div&gt;Freebies&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;div&gt;Great Deals&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;div id=main style=&quot;overflow: hidden&quot;&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;div&gt;Deals in your area:&lt;/div&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;ul&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;li&gt;Buy 1 lawyer, get 1 free&lt;/li&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;li&gt;Free dental fillings&lt;/li&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	&lt;/ul&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">&lt;/div&gt;
</span></pre>
<p>Rendered, it looks like this:</p>
<div style='margin-left: auto; margin-right: auto; width: 300px; font: 14px "Times New Roman";'>
	<div id=sidebar style="float: left; width: 75px; background-color: #0a0; color: white;">
		<div>Coupons</div>
		<div>Freebies</div>
		<div>Great Deals</div>
	</div>
	<div id=main style="overflow: hidden">
		<div>Deals in your area:</div>
		<ul>
		<li>Buy 1 lawyer, get 1 free</li>
		<li>Free dental fillings</li>
		</ul>
	</div>
</div>
<p>In this document, after we've laid out the sidebar, we can continue on and lay out the main part of the page entirely in parallel. We can lay out the block &quot;Deals in your area&quot; in parallel with the two list items &quot;Buy 1…&quot; and &quot;Free dental fillings&quot;. It turns out that this pattern is an extremely common way to create sidebars in real Web pages, so the ability to lay out the insides of block formatting contexts in parallel is a crucial optimization in practice. The upshot of all this is that block formatting contexts are a double-edged sword: they add an unfortunate dependency between heights and widths, but they enable us to recover parallelism even when blocks are impacted by floats, since we can lay out their interior in parallel.</p>
<h2>Conclusion</h2>
<p>No doubt about it, CSS 2.1 is tricky—floats perhaps more than anything else. But in spite of their difficulties, we're finding that there are unexpected places where we can take advantage of parallelism to make a faster engine. I'm cautiously optimistic that Servo's approaching the right design here—not only to make new content faster but also to accelerate the old.</p>

  </div>

  <div>
    <p><span class="share-box">Share:</span> <a href="http://twitter.com/share?text=Revamped Parallel Layout in Servo&url=_posts/2014-02-25-revamped-parallel-layout-in-servo.html" target="_blank">Twitter</a>, <a href="https://www.facebook.com/sharer.php?u=_posts/2014-02-25-revamped-parallel-layout-in-servo.html" target="_blank">Facebook</a></p>
  </div>

  <!--<div class="date">
    Written on February 25, 2014
  </div>-->
</article>
        </div>
      </div>

      <div class="wrapper-footer">
        <div class="container">
          <footer class="footer">
            














          </footer>
        </div>
      </div>
    </div>

    

  </body>
</html>

