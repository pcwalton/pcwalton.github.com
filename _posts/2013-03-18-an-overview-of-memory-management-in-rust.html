<!DOCTYPE html>
<html lang="en">
  <head>
    <title>An Overview of Memory Management in Rust – pcwalton – pcwalton's blog</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>


<meta property="og:description" content="One of the key features of Rust that sets it apart from other new languages is that its memory management is manual—the programmer has explicit control over where and how memory is allocated and deallocated. In this regard, Rust is much more like C++ than like Java, Python, or Go, to name a few. This is an important design decision that makes Rust able to function in performance-critical domains that safe languages previously haven't been able to—top-of-the line games and Web browsers, for example—but it adds a nontrivial learning curve to the language.
" />

<meta name="author" content="pcwalton" />


<meta property="og:title" content="An Overview of Memory Management in Rust" />
<meta property="twitter:title" content="An Overview of Memory Management in Rust" />



<meta property="og:image" content="http://pcwalton.github.io"/>
<meta property="twitter:image" content="http://pcwalton.github.io"/>



    <link rel="stylesheet" type="text/css" href="http://pcwalton.github.io/assets/style.css" />
    <link rel="alternate" type="application/rss+xml" title="pcwalton - pcwalton's blog" href="http://pcwalton.github.io/feed.xml" />
    <link rel="canonical" href="_posts/2013-03-18-an-overview-of-memory-management-in-rust.html" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    {left: '$$$', right: '$$', display: true},
                    {left: '$$', right: '$$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

    <meta name="theme-color" content="#000000">
    <link rel="icon" type="image/png" sizes="32x32" href="http://pcwalton.github.io/images/favicon-32x32.png">
    

  </head>

  <body>
    <div id="bar"></div>
    <div class="wrapper-container">
      <div class="wrapper-masthead">
        <div class="container">
          <header class="masthead clearfix">
            

            <div class="site-info">
              <h1 class="site-name"><a href="http://pcwalton.github.io/">pcwalton</a></h1>
              <p class="site-description">pcwalton's blog</p> 
            </div>

            <nav>
              <a href="http://pcwalton.github.io/">Home</a>
            </nav>
          </header>
        </div>
      </div>

      <div class="wrapper-main">
        <div id="main" role="main" class="container">

<article class="post detailed">
  <h1>An Overview of Memory Management in Rust</h1>

  <div>
    <p class="author_title">Patrick Walton  ·  March 18, 2013</p>
    
    <div class="post-tags">
      
        
      
      
    </div>
  </div>
    
  <div class="entry">
    <p>One of the key features of Rust that sets it apart from other new languages is that its memory management is <em>manual</em>—the programmer has explicit control over where and how memory is allocated and deallocated. In this regard, Rust is much more like C++ than like Java, Python, or Go, to name a few. This is an important design decision that makes Rust able to function in performance-critical domains that safe languages previously haven't been able to—top-of-the line games and Web browsers, for example—but it adds a nontrivial learning curve to the language.</p>
<p>For programmers familiar with modern C++, this learning curve is much shallower, but for those who are used to other languages, Rust's smart pointers can seem confusing and complex. In keeping with the systems-oriented nature of Rust, this post is designed to explain how Rust's memory management works and how to effectively use it.</p>
<h2>Smart pointers</h2>
<p>In many languages with manual memory management, like C, you directly allocate and free memory with calls to special functions. For example:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">void f() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    int *x = malloc(sizeof(int));  /* allocates space for an int on the heap */
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    *x = 1024;                     /* initialize the value */
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    printf(&quot;%d\n&quot;, *x);            /* print it on the screen */
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    free(x);                       /* free the memory, returning it to the heap */
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>C gives you a great deal of control over where memory is allocated and deallocated. Memory is allocated with a special function <code>malloc</code>, and it is freed with a special function <code>free</code>. After the call to <code>free</code>, it is an error to attempt to use <code>x</code>, as it is a <em>dangling pointer</em>. A dangling pointer points to invalid memory, but the C compiler makes no attempt to prevent you from using it; it's your responsibility to avoid touching it after freeing the memory it points to.</p>
<p>Rust gives you the same level of control over memory, but it works somewhat differently. Let's see how the same piece of code looks in Rust:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn f() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let x: ~int = ~1024;          // allocate space and initialize an int
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">                                  // on the heap
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(fmt!(&quot;%d&quot;, *x));      // print it on the screen
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">} // &lt;-- the memory that x pointed at is automatically freed here
</span></pre>
<p>There are three main differences to notice here:</p>
<ol>
<li>
<p>In C, you allocate memory first (with the call to <code>malloc</code>), and then you initialize it (in the example above, with the <code>*x = 1024</code> assignment). Rust fuses the two operations together into the <code>~</code> allocation operator, so that you don't accidentally forget to initialize memory before you use it.</p>
</li>
<li>
<p>In C, the call to <code>malloc</code> returns a plain pointer, <code>int *</code>. In Rust, the <code>~</code> operator, which allocates memory, returns a special <em>smart pointer</em> to an int. Because this type of smart pointer is so common, its name is just a single character, <code>~</code>—thus the type of this smart pointer is written as <code>~int</code>.</p>
</li>
<li>
<p>You don't call <code>free</code> manually in Rust. Rather, the compiler automatically frees the memory for you when a smart pointer goes out of scope.</p>
</li>
</ol>
<p>As it turns out, points (2) and (3) are very intertwined, and together they form the cornerstone of Rust's memory management system. Here's the idea: Unlike C, allocation functions in Rust don't return a raw pointer to the space they allocate. Instead, they return a <em>smart pointer</em> to the space. A smart pointer is a special kind of value that controls when the object is freed. Like a raw pointer in C, you can access the data that a smart pointer refers to with <code>*</code>. But unlike a raw pointer, <em>when the smart pointer to an allocation goes out of scope, that allocation is automatically freed.</em> In this way, smart pointers are &quot;smart&quot; because they not only track where an object is but also track how to clean it up.</p>
<p>Unlike C, in Rust you never call <code>free</code> directly. Instead, you rely on smart pointers to free all allocations. The most basic reason for this is that smart pointers make it harder to forget to free memory. In C, if you forget to call <code>free</code>, you have a <em>memory leak</em>, which means that the memory will not be cleaned up until the program exits. However, in Rust, the compiler will automatically insert the code necessary to free the memory for you when the smart pointer pointing to your data goes out of scope.</p>
<p>Rust has multiple types of smart pointers, corresponding to the different strategies that programs use to reclaim memory. Some smart pointers, namely <code>~</code> and <code>@</code> (which we will cover shortly), have special names known to the compiler, because they're so common. (Having to type long names like <code>unique_ptr</code> all the time would be a burden.) Other smart pointers, such as <code>ARC</code> (which allows you to share read-only data between threads), are in the standard library and are not built into the compiler.</p>
<p>The pointer covered above is known as the <em>unique smart pointer</em> <code>~</code>. We call it &quot;unique&quot; because there is always only one smart pointer pointing to each allocation. The other type of smart pointer built into the language is the <em>managed smart pointer</em>, which allows <em>multiple</em> smart pointers to point to the same allocation and uses <em>garbage collection</em> to determine when to free it. Here's an example of a managed smart pointer in use:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn foo() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let x: @int = @1024;     // allocate space and initialize an int
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">                             // on the heap
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    bar(x);                  // pass it to `bar`
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(fmt!(&quot;%d&quot;, *x)); // print it on the screen
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">} // &lt;-- the memory can be freed here
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn bar(x: @int) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let y: @int = x;         // make a new smart pointer to `x`
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">} // &lt;-- despite `y` going out of scope, the memory is *not* freed here
</span></pre>
<p>The key difference between <code>~</code> and <code>@</code> is that <code>@</code> allows <em>multiple</em> smart pointers to point to the same data, and the data is cleaned up only after the <em>last</em> such smart pointer disappears. Notice that, in this example, the memory pointed at by <code>y</code> (which is the same as the memory pointed at by <code>x</code>) is not freed at the end of the function <code>bar</code>, because <code>x</code> is still in use and also points to the same data. The fact that <code>@</code> allows multiple smart pointers to the same data, as well as the fact that the allocation is freed only when all of those pointers go out of scope, make managed smart pointers very useful. However, they can be less efficient than unique smart pointers, as they require garbage collection at runtime.</p>
<h2>References</h2>
<p>Recall that a smart pointer is a pointer that automatically frees the memory that it points to when it goes out of scope. Perhaps surprisingly, it often turns out that it's useful to have a kind of pointer that <em>doesn't</em> free the memory that it points to. Consider this code:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">struct Dog {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    name: ~str    // a unique smart pointer to a string
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn dogshow() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let dogs: [~Dog * 3] = [        // create an array of Dog objects
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Spot&quot;   },   // use unique smart pointers to
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">                                    // allocate
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Fido&quot;   },
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Snoopy&quot; },
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    ];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    for dogs.each |dog| {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        println(fmt!(&quot;Say hello to %s&quot;, dog.name));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">} // &lt;-- all dogs destroyed here
</span></pre>
<p>Suppose that we wanted to single Fido out as the winner of the dog show. We might try this code:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn dogshow() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let dogs: [~Dog * 3] = [
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Spot&quot;   },
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Fido&quot;   },
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Snoopy&quot; },
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    ];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let winner: ~Dog = dogs[1];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    for dogs.each |dog| {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    println(fmt!(&quot;Say hello to %s&quot;, dog.name));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(fmt!(&quot;And the winner is: %s!&quot;, winner.name));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">} // &lt;-- all dogs, and `winner`, destroyed here
</span></pre>
<p>But this code won't compile. The reason is that, if it did, Fido would be destroyed twice. Remember that <em>unique smart pointers free the allocations they point to when they go out of scope</em>. The code attempts to make a second smart pointer to Fido at the time it executes the line <code>let winner: ~Dog = dogs[1];</code> If the compiler allowed this to proceed, then at the end of the block, the program would attempt to free Fido twice—once when it frees the original smart pointer embedded within the <code>dogs</code> array, and once when it frees <code>winner</code>.</p>
<p>What we really want is for <code>winner</code> to be a pointer that <em>doesn't</em> free the allocation that it points to. In fact, what we want isn't a smart pointer at all; we want a <em>reference</em>. Here's the code rewritten to use one:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn dogshow() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let dogs: [~Dog * 3] = [
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Spot&quot;   },
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Fido&quot;   },
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        ~Dog { name: ~&quot;Snoopy&quot; },
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    ];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let winner: &amp;Dog = dogs[1];  // note use of `&amp;` to form a reference
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    for dogs.each |dog| {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    println(fmt!(&quot;Say hello to %s&quot;, dog.name));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(fmt!(&quot;And the winner is: %s!&quot;, winner.name));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">} // &lt;-- all dogs destroyed here
</span></pre>
<p>This code will now compile. Here, we convert <code>winner</code> into a reference, notated in Rust with <code>&amp;</code>. You can take a reference to any smart pointer type in Rust by simply assigning it to a value with a reference type, as the <code>let winner: &amp;Dog = dogs[1]</code> line does.</p>
<p>References (also known as <em>borrowed pointers</em>) don't cause the compiler to free the data they refer to. However, they don't <em>prevent</em> the compiler from freeing anything either. They have no effect on what smart pointers will do; regardless of how many references you have, a unique smart pointer will always free the data that it points to when it goes out of scope, and a managed smart pointer will always free its data when all managed smart pointers to the same allocation go out of scope.</p>
<p>This is important to keep in mind. Code like this will not compile:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn foo() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let y: &amp;int;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        let x: ~int = ~2048;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        y = x;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    } // &lt;-- x freed here
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    println(fmt!(&quot;Your lucky number is: %d&quot;, *y)); // ERROR: accesses freed data!
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>In languages like C++, code like this could cause faults from attempting to access invalid memory. As it turns out, however, this piece of code won't compile—the Rust compiler can and does prevent you from writing code like this at compile time. Essentially, the Rust compiler <em>tracks where each reference came from</em> and reports an error if a reference persists longer than the allocation it points into. This means that, generally speaking, you can use references all you like and have the confidence that they won't result in hard-to-diagnose errors at runtime.</p>
<h2>Conclusion</h2>
<p>These ideas—smart pointers and references—form the basis of memory management in Rust. If you're a C++ programmer, most of this will (hopefully!) simply have been an exercise in learning different syntax. For other programmers, these concepts are likely more foreign. But using these tools, you can write code with fine-grained control over memory, with improved safety over languages like C.</p>

  </div>

  <div>
    <p><span class="share-box">Share:</span> <a href="http://twitter.com/share?text=An Overview of Memory Management in Rust&url=_posts/2013-03-18-an-overview-of-memory-management-in-rust.html" target="_blank">Twitter</a>, <a href="https://www.facebook.com/sharer.php?u=_posts/2013-03-18-an-overview-of-memory-management-in-rust.html" target="_blank">Facebook</a></p>
  </div>

  <!--<div class="date">
    Written on March 18, 2013
  </div>-->
</article>
        </div>
      </div>

      <div class="wrapper-footer">
        <div class="container">
          <footer class="footer">
            














          </footer>
        </div>
      </div>
    </div>

    

  </body>
</html>

