<!DOCTYPE html>
<html>
  <head>
    <title>A Hard Case for Memory Safety – pcwalton – pcwalton's blog</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>


<meta property="og:description" content="Quick quiz: In this C++ program, is the definition of munge guaranteed to be memory safe? (Assume that the definition of increment_counter uses only modern C++ idioms and doesn't do anything like dereference an invalid pointer.)
" />

<meta name="author" content="pcwalton" />


<meta property="og:title" content="A Hard Case for Memory Safety" />
<meta property="twitter:title" content="A Hard Case for Memory Safety" />



<meta property="og:image" content="http://pcwalton.github.com"/>
<meta property="twitter:image" content="http://pcwalton.github.com"/>



    <link rel="stylesheet" type="text/css" href="http://pcwalton.github.com/assets/style.css" />
    <link rel="alternate" type="application/rss+xml" title="pcwalton - pcwalton's blog" href="http://pcwalton.github.com/feed.xml" />
    <link rel="canonical" href="_posts/2013-04-12-a-hard-case-for-memory-safety.html" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    {left: '$$$', right: '$$', display: true},
                    {left: '$$', right: '$$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

    <meta name="theme-color" content="#000000">
    <link rel="icon" type="image/png" sizes="32x32" href="http://pcwalton.github.com/images/favicon-32x32.png">
    

  </head>

  <body>
    <div id="bar"></div>
    <div class="wrapper-container">
      <div class="wrapper-masthead">
        <div class="container">
          <header class="masthead clearfix">
            

            <div class="site-info">
              <h1 class="site-name"><a href="http://pcwalton.github.com/">pcwalton</a></h1>
              <p class="site-description">pcwalton's blog</p> 
            </div>

            <nav>
              <a href="http://pcwalton.github.com/">Home</a>
            </nav>
          </header>
        </div>
      </div>

      <div class="wrapper-main">
        <div id="main" role="main" class="container">

<article class="post detailed">
  <h1>A Hard Case for Memory Safety</h1>

  <div>
    <p class="author_title">Patrick Walton  ·  April 12, 2013</p>
    
    <div class="post-tags">
      
        
      
      
    </div>
  </div>
    
  <div class="entry">
    <p>Quick quiz: In this C++ program, is the definition of <code>munge</code> guaranteed to be memory safe? (Assume that the definition of <code>increment_counter</code> uses only modern C++ idioms and doesn't do anything like dereference an invalid pointer.)</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">#include &lt;iostream&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">#include &lt;vector&gt;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">class foo {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">public:
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    std::vector&lt;int&gt; indices;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    int counter;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    foo() : indices(), counter(0) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        indices.push_back(1);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        indices.push_back(2);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        indices.push_back(3);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    void increment_counter();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    int &amp;get_first_index() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        assert(indices.size() &gt; 0);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        return indices[0];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    void munge() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        int &amp;first = get_first_index();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        increment_counter();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        std::cout &lt;&lt; first &lt;&lt; std::endl;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        first = 20;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">int main() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    foo foo;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    foo.munge();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    return 0;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>The answer: Even with this caveat, we can't tell! It depends on the definition of <code>increment_counter</code>.</p>
<p>If <code>increment_counter</code> has this definition, the code is memory safe:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">void foo::increment_counter() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    counter++;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>But if <code>increment_counter</code> has this definition, for example, then it isn't:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">void foo::increment_counter() {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    indices.clear();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    counter++;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>This definition would cause the <code>first</code> reference in <code>munge</code> to become a dangling reference, and the call to <code>std::cout</code> and subsequent assignment of <code>first</code> will have undefined behavior. If <code>first</code> were not an <code>int</code> but were instead an instance of a class, and <code>munge</code> attempted to perform a virtual method call on it, then this would constitute a critical security vulnerability.</p>
<p>The point here is that determining memory safety in C++ requires <em>non-local</em> reasoning. Any analysis that tries to determine safety of C++ code, whether performed by a machine or performed by a human auditor, has to analyze many functions all at once, rather than one function at a time, to determine whether the code is memory safe. As this example illustrates, sticking to modern C++ coding styles, even with bounds checks, is not enough to prevent this.</p>
<p>There are a few ways around this:</p>
<ul>
<li>
<p>For each function call, analyze the source to the called function to determine whether it's memory safe <em>in the context of the caller</em>. This doesn't always work, though: it's hard or impossible when function pointers or virtual methods are involved (which function ends up being called?), and it's hard with separately compiled code (what if the called function is in a DLL that you don't have source for?)</p>
</li>
<li>
<p>Change the type of <code>indices</code> to <code>std::vector&lt;std::shared_ptr&lt;int&gt;&gt;</code>; i.e. use reference counting to keep the pointer alive. This has a runtime cost.</p>
</li>
<li>
<p>Inline the body of <code>increment_counter</code>, so that the memory safety of <code>munge</code> is immediately clear.</p>
</li>
<li>
<p>Make <code>increment_counter</code> a class method (or just a function) instead of an instance method, and have it take <code>counter</code> by reference. The idea here is to prevent the possibility that <code>increment_counter</code> could mess with <code>indices</code> in any way by shutting off its access to it.</p>
</li>
</ul>
<p>What does this have to do with Rust? In fact, this error corresponds to a borrow check error that Brian Anderson hit when working on the scheduler. In Rust, the corresponding code looks something like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">impl Foo {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn get_first_index(&amp;&#39;a mut self) -&gt; &amp;&#39;a mut int {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        assert!(self.indices.len() &gt; 0);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        return &amp;mut indices[0];
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    fn munge(&amp;mut self) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        let first = self.get_first_index();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        self.increment_counter(); // ERROR
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        println(first.to_str());
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        *first = 20;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>This causes a borrow check error because the <code>first</code> reference conflicts with the call to <code>increment_counter</code>. The reason the borrow check complains is that the borrow check only checks one function at a time, and it could tell (quite rightly!) that the call to <code>increment_counter</code> might be unsafe. The solution is to make <code>increment_counter</code> a static method that only has access to counter; i.e. to rewrite the <code>self.increment_counter()</code> line as follows:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Foo::increment_counter(&amp;mut self.counter);
</span></pre>
<p>Since the borrow check now sees that <code>increment_counter</code> couldn't possibly destroy the <code>first</code> reference, it now accepts the code.</p>
<p>Fortunately, such borrow check errors are not as common anymore, with the new simpler borrow check rules. But it's interesting to see that, when they do come up, they're warning about real problems that affect any language with manual memory management. In the C++ code above, most programmers probably wouldn't notice the fact that the memory safety of <code>munge</code> depends on the definition of <code>increment_counter</code>. The challenge in Rust, then, will be to make the error messages comprehensible enough to allow programmers to understand what the borrow checker is warning about and how to fix any problems that arise.</p>

  </div>

  <div>
    <p><span class="share-box">Share:</span> <a href="http://twitter.com/share?text=A Hard Case for Memory Safety&url=_posts/2013-04-12-a-hard-case-for-memory-safety.html" target="_blank">Twitter</a>, <a href="https://www.facebook.com/sharer.php?u=_posts/2013-04-12-a-hard-case-for-memory-safety.html" target="_blank">Facebook</a></p>
  </div>

  <!--<div class="date">
    Written on April 12, 2013
  </div>-->
</article>
        </div>
      </div>

      <div class="wrapper-footer">
        <div class="container">
          <footer class="footer">
            














          </footer>
        </div>
      </div>
    </div>

    

  </body>
</html>

