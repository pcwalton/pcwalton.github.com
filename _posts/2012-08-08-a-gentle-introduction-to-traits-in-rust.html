<!DOCTYPE html>
<html lang="en">
  <head>
    <title>A Gentle Introduction to Traits in Rust – pcwalton – pcwalton's blog</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>


<meta property="og:description" content="Rust traits pack a lot of flexibility into a simple system, and they're one of my favorite features of the language. But as a result of the rapid pace of the language's development, there's been a fair amount of confusion as to how they work. As such, I figured I'd write up a quick tutorial explaining why and how to use them.
" />

<meta name="author" content="pcwalton" />


<meta property="og:title" content="A Gentle Introduction to Traits in Rust" />
<meta property="twitter:title" content="A Gentle Introduction to Traits in Rust" />



<meta property="og:image" content="http://pcwalton.github.io"/>
<meta property="twitter:image" content="http://pcwalton.github.io"/>



    <link rel="stylesheet" type="text/css" href="http://pcwalton.github.io/assets/style.css" />
    <link rel="alternate" type="application/rss+xml" title="pcwalton - pcwalton's blog" href="http://pcwalton.github.io/feed.xml" />
    <link rel="canonical" href="_posts/2012-08-08-a-gentle-introduction-to-traits-in-rust.html" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    {left: '$$$', right: '$$', display: true},
                    {left: '$$', right: '$$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

    <meta name="theme-color" content="#000000">
    <link rel="icon" type="image/png" sizes="32x32" href="http://pcwalton.github.io/images/favicon-32x32.png">
    

  </head>

  <body>
    <div id="bar"></div>
    <div class="wrapper-container">
      <div class="wrapper-masthead">
        <div class="container">
          <header class="masthead clearfix">
            

            <div class="site-info">
              <h1 class="site-name"><a href="http://pcwalton.github.io/">pcwalton</a></h1>
              <p class="site-description">pcwalton's blog</p> 
            </div>

            <nav>
              <a href="http://pcwalton.github.io/">Home</a>
            </nav>
          </header>
        </div>
      </div>

      <div class="wrapper-main">
        <div id="main" role="main" class="container">

<article class="post detailed">
  <h1>A Gentle Introduction to Traits in Rust</h1>

  <div>
    <p class="author_title">Patrick Walton  ·  August  8, 2012</p>
    
    <div class="post-tags">
      
        
      
      
    </div>
  </div>
    
  <div class="entry">
    <p>Rust traits pack a lot of flexibility into a simple system, and they're one of my favorite features of the language. But as a result of the rapid pace of the language's development, there's been a fair amount of confusion as to how they work. As such, I figured I'd write up a quick tutorial explaining why and how to use them.</p>
<p>This tutorial assumes only basic knowledge of C-like languages, so I'll try to explain everything specific to Rust that might be unclear along the way. Also note that a couple of these features are unimplemented, so if you try this today the syntax will be a little different.</p>
<h2>Simple implementations</h2>
<p>In keeping with the theme of my previous blog posts on classes, let's start by writing a game. I'll start by defining a struct <code>Monster</code> and a struct <code>Player</code> like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">struct Monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    name: &amp;str;      // `&amp;str` is a reference to a string
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    mut health: int; // `mut` indicates that the health can be changed
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">struct Player {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    mut health: int;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Now I can create instances of each:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn main() {  // `fn` defines a function
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    let monster = Monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    	name: &quot;Gelatinous Cube&quot;,
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		health: 50
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	let player = Player {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		health: 100
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	};
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Without some functionality, this isn't a particularly interesting game. So let's add a method to <code>Monster</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">impl Monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	fn attack(&amp;self, player: &amp;Player) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	    // fmt! is string formatting; this prints &quot;Gelatinous Cube hits you!&quot;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		io::println(fmt!(&quot;%s hits you!&quot;, self.name));
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		player.health -= 10;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>And I can call it this way, inside <code>main</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">monster.attack(&amp;player);
</span></pre>
<p>There are several things to note here.</p>
<ul>
<li>
<p>References are explicit in Rust: the <code>&amp;</code> sigil indicates that the method <code>attack</code> takes a reference to the player, not the player itself. If I didn't write that, then the player would be copied into the method instead (and we'd get a compiler warning, because this indicates a bug).</p>
</li>
<li>
<p>I use the keyword <code>impl</code> to declare methods for a type. <code>impl</code> declarations can appear  anywhere in the module that declared the type. The <code>struct</code> and <code>impl</code> pair appears a lot in Rust code; it nicely separates out data from implementation. Objective-C and C++ programmers will find this familiar.</p>
</li>
<li>
<p>Within an implementation, functions with a <code>self</code> parameter become methods. Python programmers will find this &quot;explicit self&quot; familiar. Because references are explicit in Rust, you specify how <code>self</code> is supposed to be passed; in this case, by reference (<code>&amp;self</code>).</p>
</li>
</ul>
<h2>Generics</h2>
<p>Now that we have basic implementations covered, let's look at something completely different: generics. (We'll come back to implementations later on.) Like many other languages, Rust features generic functions: functions that can operate on many different types. For example, here's a function that returns true if a vector is empty:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">// Vectors are written with square brackets around the type; e.g. a vector of
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">// ints is written `[int]`.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">fn is_empty&lt;T&gt;(v: &amp;[T]) -&gt; bool {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	return v.len() == 0;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>The generic type parameters are written inside the angle brackets (<code>&lt;</code> and <code>&gt;</code>), after the function name.</p>
<p>There's nothing much more to say here; generics are pretty simple. In this form, however, they're pretty limited, as we'll see.</p>
<h2>Limitations of generics</h2>
<p>Let's go back to our game example. Suppose I want to add functionality to save the state of the game to disk in <a href="http://en.wikipedia.org/wiki/JSON">JSON</a>. I'll implement some methods on <code>Monster</code> and <code>Player</code> to do this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">impl Monster {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	// `~str` means &quot;a pointer to a string that&#39;ll be automatically freed&quot;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	fn to_json(&amp;self) -&gt; ~str {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		return fmt!(&quot;{ name: \&quot;%s\&quot;, health: %d }&quot;, self.name, self.health);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">impl Player {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	fn to_json(&amp;self) -&gt; ~str {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		return fmt!(&quot;{ health: %d }&quot;, self.health);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Now imagine that I wanted a function to save any actor (either a monster or a player) into a file. Because monsters and players are different types, I need to use a generic function to handle both. My first attempt at the function looks like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn save&lt;T&gt;(filename: &amp;str, actor: &amp;T) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	// Because the writer returns an error code, I use .get() to mean &quot;require
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	// that this succeeded, and abort the program if it didn&#39;t&quot;.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	let writer = io::file_writer(filename, [ io::create, io::truncate ]).get();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	writer.write(actor.to_json());
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	// Because of RAII, the file will automatically be closed.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Uh-oh. This doesn't compile. I get the following error: &quot;attempted access of field <code>to_json</code> on type <code>&amp;T</code>, but no public field or method with that name was found&quot;.</p>
<p>What the Rust compiler is telling me is that it doesn't know that the type <code>T</code> in this function contains the method <code>to_json</code>. And, in fact, it might not. As written above, it'd be perfectly legal to call <code>save</code> on any type at all:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">struct Penguin {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	name: &amp;str;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">save(&quot;penguin.txt&quot;, &amp;Penguin { name: &quot;Fred&quot; });
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">// But how do I convert penguins to JSON?
</span></pre>
<p>So I'm stuck. But Rust provides a solution: traits.</p>
<h2>Trait declaration</h2>
<p>Traits are the way to tell the Rust compiler about <em>functionality that a type must provide</em>. They're very similar in spirit to interfaces in Java, C#, and Go, and are similar in implementation to typeclasses in Haskell. They provide the solution to the problem I'm facing: I need to tell the Rust compiler, first of all, that some types can be converted to JSON, and, additionally, for the types that can be converted to JSON, how to do it.</p>
<p>To define a trait, I simply use the <code>trait</code> keyword:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">trait ToJSON {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	fn to_json(&amp;self) -&gt; ~str;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>This declares a trait named <code>ToJSON</code>, with one method that all types that implement the trait must define. That method is named <code>to_json</code>, and it takes its <code>self</code> parameter by reference.</p>
<p>Now I can define implementations of <code>ToJSON</code> for the various types I'm interested in. These implementations are exactly the same as above, except that we add <code>: ToJSON</code>.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">impl Monster : ToJSON {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	// `~str` means &quot;a pointer to a string that&#39;ll be automatically freed&quot;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	fn to_json(&amp;self) -&gt; ~str {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		return fmt!(&quot;{ name: \&quot;%s\&quot;, health: %d }&quot;, self.name, self.health);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">impl Player : ToJSON {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	fn to_json(&amp;self) -&gt; ~str {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">		return fmt!(&quot;{ health: %d }&quot;, self.health);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>That's all there is to it. Now I can modify the <code>save</code> function so that it does what I want.</p>
<h2>Trait usage</h2>
<p>Recall that the reason why the <code>save</code> function didn't compile is that the Rust compiler didn't know that the <code>T</code> type contained a <code>to_json</code> method. What I need is some way to tell the compiler that this function only accepts types that contain the methods I need to call. This is accomplished through <em>trait restrictions</em>. I modify the <code>save</code> function as follows:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">fn save&lt;T:ToJSON&gt;(filename: &amp;str, actor: &amp;T) {
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	let writer = io::file_writer(filename, [ io::create, io::truncate ]).get();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">	writer.write(actor.to_json());
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Note the addition of <code>:ToJSON</code> after the type parameter. This indicates that the function can only be called with types that implement the trait.</p>
<p>Now these calls to <code>save</code> will compile:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">save(&quot;player.txt&quot;, &amp;player);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">save(&quot;monster.txt&quot;, &amp;monster);
</span></pre>
<p>But this call will not:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">save(&quot;penguin.txt&quot;, &amp;Penguin { name: &quot;Fred&quot; });
</span></pre>
<p>I get the error &quot;failed to find an implementation of trait <code>ToJSON</code> for <code>Penguin</code>&quot;, just as expected.</p>
<h2>Summing up</h2>
<p>These are the basic features of traits and comprise most of what Rust programmers will need to know. There are only a few more features beyond these, which I'll mention briefly:</p>
<ul>
<li>
<p><em>Special traits</em>. Some traits are known to the compiler and represent the built-in operations. Most notably, this includes the ubiquitous <code>copy</code> trait, which invokes the copy operation that occurs when you assign with <code>let x = y</code>. You'll see <code>T:copy</code> in many generic functions for this reason. Other special traits include <code>send</code>, which is a trait that indicates the type is sendable, and <code>add</code>, <code>sub</code>, etc, which indicate the built-in arithmetic operators. The key is that, in all cases, traits simply specify <em>what a generic type can do</em>; when you want to do something with a type parameter like <code>T</code>, you specify a trait.</p>
</li>
<li>
<p><em>Generic traits</em>. Traits can be generic, which is occasionally useful.</p>
</li>
<li>
<p><em>Default implementations</em>. It's often helpful for traits to provide default implementations of their methods that take over when the type doesn't provide an implementation of its own. For example, the default implementation of <code>to_json()</code> might want to use the Rust reflection API to automatically create JSON for any type, even if that type doesn't manually implement the <code>to_json()</code> method. (Note that this feature is currently being implemented.)</p>
</li>
<li>
<p><em>Trait composition</em>. Sometimes we want one trait to include another trait. For example, the <code>Num</code> trait, which all number types in the language implement, obviously includes addition, subtraction, multiplication, etc. Trait composition allows traits to be &quot;glued together&quot; in this way. Note that this isn't <em>inheritance</em>; it's simply a convenience that allows trait methods to be combined together, like a mixin. (This is not fully implemented yet.)</p>
</li>
<li>
<p><em>First-class trait values</em>. Rarely, it's necessary to have a trait be a first-class value, like in Java or Go, instead of attached to a generic type parameter. This doesn't come up particularly often, but Rust does support it in the rare cases in which it's needed. Idiomatic Rust uses generics instead of Java-like interfaces.</p>
</li>
</ul>
<p>That's about all there is to traits. Traits are essentially Rust's object system, but they're simpler than many object systems and integrate especially well with generics.</p>

  </div>

  <div>
    <p><span class="share-box">Share:</span> <a href="http://twitter.com/share?text=A Gentle Introduction to Traits in Rust&url=_posts/2012-08-08-a-gentle-introduction-to-traits-in-rust.html" target="_blank">Twitter</a>, <a href="https://www.facebook.com/sharer.php?u=_posts/2012-08-08-a-gentle-introduction-to-traits-in-rust.html" target="_blank">Facebook</a></p>
  </div>

  <!--<div class="date">
    Written on August  8, 2012
  </div>-->
</article>
        </div>
      </div>

      <div class="wrapper-footer">
        <div class="container">
          <footer class="footer">
            














          </footer>
        </div>
      </div>
    </div>

    

  </body>
</html>

